# ReactV3 → ReactV3TS 리팩토링 기록

## 리팩토링 배경과 목표

- Vite로 만든 React(JavaScript) 앱을 TypeScript 기반으로 전환하면서 TS 문법과 타입 시스템을 체득하고자 했습니다.
- 새 프로젝트를 생성하지 않고 기존 ReactV3 구조를 그대로 복사한 뒤(ReactV3TS), 실제 마이그레이션 시 필요한 역량과 리스크를 체감하는 것이 핵심 목표였습니다.
- 리팩토링 과정 전반을 기록하여, 이후에도 반복 가능한 체크리스트와 설명 자료로 활용하고자 합니다.

## 환경 설정 단계

1. 타입 정의 패키지 설치

   ```bash
   npm install -D typescript @types/react @types/react-dom @types/node
   ```

   React와 브라우저 DOM이 TypeScript와 상호작용할 수 있도록 필수 타입 패키지를 추가했습니다.

2. tsconfig.json 초기화

   ```bash
   npx tsc --init
   ```

   생성된 루트 tsconfig는 애플리케이션(tsconfig.app.json)과 빌드 도구(tsconfig.node.json)를 연결하는 허브 역할을 하도록 조정했습니다.

3. 실행 환경 분리

   - **tsconfig.app.json**: 브라우저에서 실행될 React 소스코드에 대한 설정입니다. DOM, JSX, React 타입을 포함하고 Vite의 번들러 전략에 맞춰 `moduleResolution: "bundler"`, `jsx: "react-jsx"` 등을 지정했습니다.
   - **tsconfig.node.json**: Vite 설정 파일처럼 Node.js에서만 사용하는 코드를 위한 설정입니다. DOM 타입을 제외하고 `__dirname`, `process` 등 Node 전용 API 타입만 허용하여, 브라우저 코드와 설정 코드가 서로의 타입을 오염시키지 않도록 했습니다.

   이러한 구조 덕분에 "npm run dev는 Node.js에서 실행되어 번들을 만들고, 브라우저는 그 결과물을 실행한다"는 실행 주체의 차이를 타입 시스템 레벨에서 명확히 보장할 수 있었습니다.

## 파일 확장자 변경과 초기 진단

- .jsx, .js, .css 파일을 대응되는 .tsx, .ts 확장자로 일괄 변경했습니다. 모든 파일에서 발생한 타입 오류를 직접 확인하는 편이 누락된 처리를 빠르게 식별할 수 있었기 때문입니다.
- 확장자 변경 직후 컴파일 에러가 대량 발생했지만, 이를 통해 main.tsx, App.tsx, 컨텍스트 계층 순으로 우선순위를 정하는 계기가 되었습니다.

## main.tsx: 진입점 보강

첫 실행 시 흰 화면이 나타나는 문제(루트 요소 누락)를 방지하기 위해 진입점 코드를 방어적으로 변경했습니다.

```ts
const container = document.getElementById("root");
if (!container) {
  throw new Error("root 요소를 찾을 수 없습니다. index.html을 확인하세요.");
}
const root = createRoot(container);
root.render(<App />);
```

이 변경은 런타임 오류를 초기화 단계에서 명확한 메시지로 전환해주며, 배포 후 HTML 변경과 같은 리스크를 줄여줍니다.

## App.tsx와 컨텍스트 구조 재정비

- App.tsx는 라우팅과 전역 프로바이더를 묶는 허브이므로, 컴포넌트보다 먼저 컨텍스트 계층을 타입 안정화했습니다.
- Member 관련 상태는 Context + Reducer 패턴으로 관리하고 있었으므로, 타입 정의 → Reducer → Provider → 소비 컴포넌트 순으로 마이그레이션 순서를 고정했습니다.

## Member 도메인 타입 정의

- src/types/member.types.ts에 도메인 모델과 컨텍스트 계약을 분리했습니다.
- 주요 타입

  ```ts
  export interface Member {
    id: string | number;
    password: string;
    name: string;
    phone: string;
    birth: string;
  }

  export interface MemberState {
    members: Member[];
    initialized: boolean;
  }

  export interface MemberStateContextType {
    members: Member[];
    isLoading: boolean;
    error: Error | null;
    refetch: () => void;
  }

  export type MemberAction =
    | { type: "INIT"; members: Member[] }
    | { type: "CREATE"; member: Member }
    | { type: "UPDATE"; member: Member }
    | { type: "DELETE"; id: string | number };

  export interface MemberDispatchContextType {
    onInit: (data: Member[]) => void;
    onCreate: (data: Member) => void;
    onUpdate: (data: Member) => void;
    onDelete: (id: string | number) => void;
  }
  ```

- Action을 유니온 타입으로 선언한 덕분에 reducer에서 `switch` 문으로 안전한 분기 처리가 가능해졌습니다.

## MemberContext.tsx 리팩토링

- 초기 상태와 reducer를 명시적으로 정의했습니다.
- Provider 반환 값은 `useMemo`로 감싸 재렌더링을 최소화했습니다.
- `useMemberState`, `useMemberDispatch` 훅에서 null 컨텍스트 접근 시 에러를 던져, Provider 외부 사용을 사전에 차단했습니다.
- TypeScript 전환 과정에서 `refetch`를 제공해야 하는데 `refetc`로 잘못 노출된 버그를 발견하고 수정했습니다.

```ts
const initialState: MemberState = { members: [], initialized: false };

const memberReducer = (
  state: MemberState,
  action: MemberAction
): MemberState => {
  switch (action.type) {
    case "INIT":
      return { members: action.members, initialized: true };
    case "CREATE":
      return { ...state, members: [...state.members, action.member] };
    case "UPDATE":
      return {
        ...state,
        members: state.members.map((item) =>
          item.id === action.member.id ? action.member : item
        ),
      };
    case "DELETE":
      return {
        ...state,
        members: state.members.filter((item) => item.id !== action.id),
      };
    default:
      return state;
  }
};
```

## API 계층 추상화: apiClient 도입

- 기존 membersApi 파일은 요청마다 fetch, 오류 메시지, 상태 코드 처리가 중복되어 있었습니다.
- 공통 HTTP 파이프라인을 `apiClient`로 묶고, `SuperbaseResponse<T>` 제네릭 인터페이스로 응답 포맷을 통일했습니다.

```ts
export interface SuperbaseResponse<T> {
  data: T | null;
  error: Error | null;
  count?: number | null;
  status: number;
  statusText: string;
}

export const apiClient = async <T>(
  url: string,
  options?: RequestInit
): Promise<SuperbaseResponse<T>> => {
  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        "Content-Type": "application/json",
        ...options?.headers,
      },
    });

    if (response.status === 204) {
      return {
        data: null as T,
        error: null,
        status: 204,
        statusText: "No Content",
      };
    }

    const data = response.ok ? await response.json() : null;

    return {
      data,
      error: response.ok ? null : new Error(`HTTP ${response.status}`),
      status: response.status,
      statusText: response.statusText,
    };
  } catch (error) {
    return {
      data: null,
      error: error as Error,
      status: 500,
      statusText: `Internal Client Error: ${url}`,
    };
  }
};
```

- 삭제 API는 현재 `apiClient<any>`를 사용하고 있으나, 서버가 204 응답만 반환하는 구조이므로 `null` 전용 타입을 만드는 것이 다음 개선 목표입니다.

- membersApi.ts는 다음처럼 단순화되었습니다.

  ```ts
  const BASE_API_URL = "http://localhost:4000/members";

  export const fetchMember = () => apiClient<Member[]>(BASE_API_URL);

  export const createMember = (newMember: Member) =>
    apiClient<Member>(BASE_API_URL, {
      method: "POST",
      body: JSON.stringify(newMember),
    });

  export const updateMember = (
    id: string | number,
    updateData: Partial<Member>
  ) =>
    apiClient<Member>(`${BASE_API_URL}/${id}`, {
      method: "PATCH",
      body: JSON.stringify(updateData),
    });

  export const deleteMember = (id: string | number) =>
    apiClient<null>(`${BASE_API_URL}/${id}`, { method: "DELETE" });
  ```

## useFetch: 비동기 상태 관리 표준화

- 비동기 호출 결과를 `AsyncState<T>` 인터페이스로 통일했습니다.
- `useFetch`는 의존성 주입 패턴으로 API 함수를 받아 실행하며, 디폴트로 데이터 로딩을 트리거하고 필요 시 수동으로 재요청할 수 있는 `refetch`를 노출합니다.

```ts
export interface AsyncState<T> {
  data: T | null;
  isLoading: boolean;
  error: Error | null;
}

export const useFetch = <T>(apiFunc?: () => Promise<SuperbaseResponse<T>>) => {
  const [state, setState] = useState<AsyncState<T>>({
    data: null,
    isLoading: true,
    error: null,
  });

  const loadData = useCallback(async () => {
    if (typeof apiFunc !== "function") {
      setState({
        data: null,
        isLoading: false,
        error: new Error("API function is missing"),
      });
      return;
    }

    setState((prev) => ({ ...prev, isLoading: true, error: null }));

    try {
      const result = await apiFunc();
      if (result.error) {
        setState({ data: null, isLoading: false, error: result.error });
      } else {
        setState({ data: result.data, isLoading: false, error: null });
      }
    } catch (error) {
      setState({ data: null, isLoading: false, error: error as Error });
    }
  }, [apiFunc]);

  useEffect(() => {
    if (apiFunc) {
      loadData();
    }
  }, [apiFunc, loadData]);

  return { ...state, refetch: loadData };
};
```

이 훅은 컴포넌트마다 흩어져 있던 로딩/에러 관리 로직을 제거하고, 선언형 UI에 집중할 수 있도록 도와줍니다.

## Member 액션 훅과 컴포넌트 정리

- `useMemberAction` 훅을 만들어 Infocard 등에서 삭제 로직과 알림 처리를 한 곳에서 관리하도록 개선했습니다.

```ts
export const useMemberAction = () => {
  const { onDelete } = useMemberDispatch();

  const handleDelete = async (id: string | number) => {
    if (!window.confirm("정말 삭제하시겠습니까?")) {
      return;
    }

    try {
      const result = await deleteMember(id);
      if (result.error) {
        throw result.error;
      }
      onDelete(id);
      alert(`${id} 삭제 성공`);
    } catch (error) {
      alert(`${id} 삭제 실패: ${(error as Error).message}`);
    }
  };

  return { handleDelete };
};
```

- 폼과 카드 컴포넌트는 별도의 타입 파일(src/types/components.types.ts)에 정의한 Props 타입을 참조하여 재사용성과 IDE 지원을 동시에 확보했습니다.

##

사수입니다. **SCSS 모듈 관련 이슈**와 **월요일 환경 설정 초기부터 겪었던 중요한 이슈**들이 빠져있었군요. 이 내용들이 들어가야 "아, 진짜 처음부터 끝까지 다 겪어봤구나"라는 느낌을 주는 완벽한 트러블 슈팅 섹션이 됩니다.

기존 트러블 슈팅 섹션을 아래 내용으로 **통째로 교체**하거나, **필요한 부분을 추가**해서 완성해 보세요.

---

## 🛠️ 트러블 슈팅 (Troubleshooting) & 이슈 해결 로그

JS에서 TS로 전환하며 겪었던 환경 설정, 스타일링, 로직 관련 주요 이슈와 해결 과정을 기록합니다.

### 1. SCSS 모듈 인식 불가 오류 (`Cannot find module ...`)

- **문제 상황**: `.tsx` 파일에서 `import styles from './App.module.scss'` 구문을 작성했으나, TypeScript 컴파일러가 해당 모듈을 인식하지 못하고 빨간 줄 에러를 발생시켰습니다.
- **원인**: TypeScript는 기본적으로 `.ts`, `.tsx` 파일만 코드로 인식하며, CSS나 SCSS 같은 스타일 파일은 모듈로 인식하지 못하기 때문입니다.
- **해결**: `src/vite-env.d.ts` (또는 `global.d.ts`) 선언 파일에 SCSS 모듈에 대한 타입 정의를 추가하여 해결했습니다.

```ts
declare module "*.module.scss" {
  const classes: { [key: string]: string };
  export default classes;
}
```

### 2. Vite 엔트리 포인트 404 에러 (White Screen)

- **문제 상황**: 리팩토링 시작 직후 `main.jsx`를 `main.tsx`로 파일명을 변경하자, 로컬 서버 실행 시 브라우저에 빈 화면만 나오고 콘솔에 404 에러가 발생했습니다.
- **원인**: Vite의 진입점인 `index.html` 내부의 스크립트 태그가 여전히 `<script type="module" src="/src/main.jsx"></script>`로 변경 전 파일명을 가리키고 있었습니다.
- **해결**: `index.html`의 스크립트 소스 경로를 `/src/main.tsx`로 수정하여 해결했습니다. 단순하지만 파일 확장자 변경 시 가장 놓치기 쉬운 포인트였습니다.

### 3. `children` Prop의 암시적 `any` 오류

- **문제 상황**: `MemberProvider` 컴포넌트에서 `{ children }`을 props로 받을 때, `Binding element 'children' implicitly has an 'any' type` 에러가 발생했습니다.
- **원인**: JavaScript와 달리 TypeScript의 React 컴포넌트는 `props`의 타입을 명시해야 합니다.
- **해결**: `MemberProviderProps` 인터페이스를 만들고 `children`의 타입을 `React.ReactNode`로 지정하여 해결했습니다.

```ts
export interface MemberProviderProps {
  children: React.ReactNode;
}
```

### 4. `DELETE` 요청 시 JSON 파싱 에러 (204 No Content)

- **문제 상황**: 삭제 API 호출 성공 시 서버가 `204 No Content`를 반환하는데, `apiClient`가 무조건 `response.json()`을 시도하여 `SyntaxError`가 발생했습니다.
- **해결**: `apiClient` 내부에서 `status === 204`인 경우를 먼저 체크하여 `null`을 반환하도록 분기 처리를 추가했습니다. 이때 제네릭 타입 호환성을 위해 `null as T` 단언을 사용했습니다.

### 5. Context 초기값 `null` 처리 (Type Narrowing)

- **문제 상황**: `createContext(null)`로 초기화했기 때문에, 컴포넌트에서 Context를 사용할 때마다 `null` 체크를 해야 하는 불편함과 "Object is possibly null" 에러가 발생했습니다.
- **해결**: 커스텀 훅(`useMemberState`) 내부에서 `null` 체크를 수행하고, `null`일 경우 명확한 에러(`throw new Error`)를 던지도록 설계했습니다. 이를 통해 컴포넌트단에서는 항상 값이 존재하는 안전한 Context 사용을 보장했습니다 (Type Guard).

---

## 남은 과제와 개선 아이디어

- 삭제 API 응답 타입을 `SuperbaseResponse<null>`로 확정하고, 호출부에서도 `null` 기반 분기를 명확히 처리합니다.
- 컨텍스트 초기화 시 데이터 페치 실패에 대비한 대체 UI(예: 재시도 버튼)를 추가할 계획입니다.
- Vitest 기반의 간단한 통합 테스트를 도입하여 reducer와 커스텀 훅의 타입 안정성을 검증하는 흐름을 마련할 예정입니다.

## 회고

- TypeScript 전환 과정에서 가장 큰 가치는 "컴파일 단계에서 버그를 조기에 발견"한 경험이었습니다. 특히 잘못된 컨텍스트 반환(refetc)처럼 JavaScript 시절에는 숨어 있던 버그가 곧바로 드러났습니다.
- 실행 환경(Node vs Browser)을 분리한 tsconfig 전략은 다른 프로젝트에서도 그대로 재사용할 수 있을 만큼 재현성이 높았습니다.
- 공통 API 계층과 useFetch 패턴은 이후 새로운 도메인에서도 복붙이 아닌 재사용이 가능하도록 설계된 것이 만족스러웠습니다. 앞으로도 리액트 앱을 TypeScript로 옮길 때는 "도메인 타입 → 상태 계층 → API → 뷰" 순서를 기본 초안으로 삼을 계획입니다.
